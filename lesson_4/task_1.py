'''
Проанализировать скорость и сложность одного любого алгоритма,
разработанных в рамках практического задания первых трех уроков.
Примечание: попробуйте написать несколько реализаций алгоритма и сравнить их.
'''
import cProfile
import task_2


print('Функция без использования алгоритма Эратосфена')
'''
Алгоритм функции основан на том, что каждое число проверяется на делимость на простые числа (3,5,7,9) и цикл проверки 
повторяется, пока не будет найдено i-тое простое число.
Предположительно, алгоритм имеет сложность O(2^n)
'''
cProfile.run('task_2.prime(100)')
# 374 function calls in 0.000 seconds

cProfile.run('task_2.prime(1000)')
# 4963 function calls in 0.034 seconds

cProfile.run('task_2.prime(10000)')
# 62368 function calls in 3.101 seconds

cProfile.run('task_2.prime(100000)')
# 749858 function calls in 335.856 seconds (~ 5-6 минут)


print('Функция с использованием алгоритма Эратосфена')
'''
Алгоритм основан на определении составных чисел, отмечая нулевым значением все числа, которые кратны простым. 
Особвенность алгоритма в том, что он принимает заранее известный диапазон чисел. За один цикл 
помечаются все числа, кратные одному простому числу. Например, число 2 простое - значит за один цикл, отмечаются 0
все числа, кратные 2. За следующий - все числа кратные 3 и т.д.
Предположительн сложность алгоритма O(n log n)
'''
cProfile.run('task_2.erato(100)')
# 1143 function calls in 0.001 seconds

cProfile.run('task_2.erato(1000)')
# 16508 function calls in 0.012 seconds

cProfile.run('task_2.erato(10000)')
# 215385 function calls in 0.164 seconds

cProfile.run('task_2.erato(100000)')
# 2649220 function calls in 2.362 seconds

cProfile.run('task_2.erato(1000000)')
# 31390612 function calls in 27.129 seconds

# Выводы
# Функция без использования алгоритма Эратосфена оказалась менее эффективна при увеличении входного значения,
# Алгоритм Эратосфена более эффективен при большом входном значении и время выполнения увеличивается не так быстро